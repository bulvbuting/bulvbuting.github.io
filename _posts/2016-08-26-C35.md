---
layout: post
tags: C 代码练习 二叉树
title: C语言练习（34）--对二叉树值为x的结点的操作
---

使用工具：DEV C++

题目描述：

1. m,n为指向二叉树的两个结点的指针，求这两个结点最近公共祖先的指针

```c

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <vector> 
#define MaxSize 10

using namespace std;

typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild; 
}BiTNode, *	BiTree;

typedef struct Stack {
	struct BiTNode *data[MaxSize];
	int top;
}Stack;

BiTree T;
Stack S;

void InitStack() {
	S.top = 0;
}

void pushStack(BiTNode *p) {
	if(S.top == MaxSize)    return;
	S.data[S.top++] = p;
}

void popStack(BiTNode *&p) {
	if(S.top == 0)    return;
	p = S.data[--S.top];
}

void createTree(BiTree &T) {
	int data;
	scanf("%d", &data);
	if(data!=-1) {
		T = (BiTree)malloc(sizeof(BiTNode));
		T->data = data;
		createTree(T->lchild);
		createTree(T->rchild);
	} else    T = NULL;
}

//查找m指针对应结点的所有祖先(后序遍历)
vector<BiTree> printParents(BiTree T, BiTNode *m) {
	vector<BiTree> a;
	if(T == NULL)    return a;
	InitStack();
	BiTNode *p = T;
	while(p!=NULL || S.top!=0) {
		if(p!=NULL) {
			if(p == m) {    //找到指针m对应的结点 
				for(int i = 0; S.top!=0; i++) {
					popStack(p);
					a.push_back(p);
				}
				return a; 
			} else {
				pushStack(p);
				p = p->lchild;
			} 
		} else {    //栈不为空 
			p = getTop();
			while(p->rchild== NULL) {
				popStack(p);
				p = getTop();
			}
			p = p->rchild;
		}
	}
}

void findParent(BiTree T, BiTNode *m, BiTNode *n, BiTNode *&r) {
	r = (BiTree)malloc(sizeof(BiTNode));
	vector<BiTree> a = printParents(T, m);
	vector<BiTree> b = printParents(T, n);
	vector<BiTree>::iterator it, it1;
	for(int i=0; i<a.size(); i++) {
		for(int j=0; j<b.size(); j++) {
			if(a[i] == b[j]) {
				r = a[i];
				return;
			}
		}
	}
}

void visit(BiTNode *p) {
	cout<<p->data<<" ";
} 

//先序遍历 
void preTree(BiTree T) {
	if(T!=NULL) {
		visit(T);
		preTree(T->lchild);
		preTree(T->rchild);
	} 
}

//中序遍历 
void inTree(BiTree T) {
	if(T!=NULL) {
		inTree(T->lchild);
		visit(T);
		inTree(T->rchild);
	}
}

int main(int argc, char** argv) {
	createTree(T);
	cout<<"先序遍历结果："; 
	preTree(T);
	cout<<endl<<"中序遍历结果：";
	inTree(T);
	BiTNode *m = T->rchild->lchild, *n = T->rchild->rchild->lchild->lchild, *r;
	findParent(T, m, n, r);
	cout<<endl<<"T->rchild->lchild和T->rchild->rchild->lchild->lchild的"<<endl<<"最近公共祖先的地址："<<r<<"|对应的结点值："<<r->data; 
	return 0;
}

```

![](/assets/img/2016-08-26-C35/2.png)
![](/assets/img/2016-08-26-C35/1.png)