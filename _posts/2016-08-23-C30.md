---
layout: post
tags: C 代码练习 二叉树 栈 队列
title: C语言练习（30）--二叉树的由下到上，由右到左的层次遍历
---

使用工具：DEV C++

题目描述：

借助栈和队列实现二叉树的由下到上，由右到左的层次遍历。

顺序层次遍历少了最后入栈的步骤，出队后，直接访问。

构造二叉树时，输入为-1表示空树。

```c

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 10

using namespace std;

typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;

typedef struct stack {
	struct BiTNode* data[MaxSize];
    int top;
}stack;

typedef struct QueueNode {    //循环队列，借助队列 
	struct BiTNode *data[MaxSize];
	int front, rear;
}Queue;
 
BiTree T;
stack S;
QueueNode Q;

void InitStack() {
    S.top = 0;
}

void InitQueue() {
    Q.front = Q.rear = 0;
}

bool IsEmptyStack() {
	if(S.top == 0)    return true;
	return false;
}

bool IsEmptyQueue() {
	if(Q.rear == Q.front)    return true;
	return false;
}

void push(stack &S, BiTNode *node) {
    if(node == NULL)    return;
    S.data[S.top++] = node;
}

void pop(stack &S, BiTNode *&node) {
	if(S.top == 0)    return;
    node = S.data[--S.top];
}

void enQueue(BiTNode *&node) {
	if((Q.rear+1)%MaxSize == Q.front)    return;
	Q.data[Q.rear] = node;
	Q.rear = (Q.rear+1)%MaxSize;
}

void deQueue(BiTNode *&node) {
	if(Q.rear == Q.front)    return;
	node = Q.data[Q.front];
	Q.front = (Q.front+1)%MaxSize;
} 

//生成二叉树 
void createBiTree(BiTree &T) {
	int a;
	scanf("%d", &a);    //头结点 
	if(a!=-1) {
		T = (BiTNode*)malloc(sizeof(BiTNode));
	    T->data = a;
	    T->lchild = T->rchild = NULL;
	    createBiTree(T->lchild);
	    createBiTree(T->rchild);
	} else {
		T = NULL;
	}
}

void visit(BiTNode *node) {
    cout<<(node->data)<<" ";
}

//先序访问递归
void PreOrder(BiTree T) {
    if (T!=NULL) {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

//中序访问递归
void InOrder(BiTree T) {
    if (T!=NULL) {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

//自下而上，自右而左的层次遍历 
void reverOrder() {
	BiTNode *p = T;
	if(T!=NULL) {
		enQueue(p);
	}
	
	while(!IsEmptyQueue()) {
		deQueue(p);
		if(p->lchild!=NULL)    enQueue(p->lchild);
		if(p->rchild!=NULL)    enQueue(p->rchild);
		push(S, p);
	}
	
	while(!IsEmptyStack()) {
		pop(S, p);
		visit(p);
	}
}

int main(int argc, char** argv) {
	createBiTree(T);
	InitStack();
	InitQueue();
	cout<<"先序递归访问二叉树：";
    PreOrder(T);
    cout<<endl<<"中序递归访问二叉树：";
    InOrder(T);
	cout<<endl<<"自下而上，自右而左的层次遍历：";
	reverOrder();
	return 0;
}

```
![](/assets/img/2016-08-23-C30/2.png)

![](/assets/img/2016-08-23-C30/1.png)