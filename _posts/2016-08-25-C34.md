---
layout: post
tags: C 代码练习 机试题
title: C语言练习（34）--对二叉树值为x的结点的操作
---

使用工具：DEV C++

题目描述：




```c

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 10

using namespace std;

typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild; 
}BiTNode, *	BiTree;

typedef struct Queue {
	struct BiTNode *data[MaxSize];
	int front, rear;
}Queue;

BiTree T;
Queue Q;

void InitQueue() {
	Q.front = Q.rear = 0;
}

bool IsEmpty() {
	if(Q.front == Q.rear)    return true;
	return false;
}

bool IsFull() {
	if((Q.rear+1)%MaxSize == Q.front)    return true;
	return false;
}

void enQueue(BiTree T) {
	if(IsFull())    return;
	Q.data[Q.rear] = T;
	Q.rear = (Q.rear+1)%MaxSize;
}

void deQueue(BiTree &T) {
	if(IsEmpty())    return;
	T = Q.data[Q.front];
	Q.front = (Q.front+1)%MaxSize;
}

void deletBiTree(BiTree T) {
	if(T!=NULL) {
		deletBiTree(T->lchild);
		deletBiTree(T->rchild);
		free(T);
	}
}

void createTree(BiTree &T) {
	int data;
	scanf("%d", &data);
	if(data!=-1) {
		T = (BiTree)malloc(sizeof(BiTNode));
		T->data = data;
		createTree(T->lchild);
		createTree(T->rchild);
	} else    T = NULL;
}

//用层次遍历的方法找到x，并且将x对应的子树删除。 
void findAndDeletX(int x) {
	BiTNode *p = T;
	if(p->data == x)
		 deletBiTree(p);
	else {
		InitQueue();
		enQueue(p);
		while(!IsEmpty()) {
			deQueue(p);
			if(p->lchild!=NULL)
				if(p->lchild->data == x) {
					deletBiTree(p->lchild);
					p->lchild = NULL;
				} else    enQueue(p->lchild);
			
			if(p->rchild!=NULL)
				if(p->rchild->data == x) {
					deletBiTree(p->rchild);
					p->rchild = NULL;
				} else    enQueue(p->rchild);
		}
	}
}

void visit(BiTNode *p) {
	cout<<p->data<<" ";
} 

//先序遍历 
void preTree(BiTree T) {
	if(T!=NULL) {
		visit(T);
		preTree(T->lchild);
		preTree(T->rchild);
	} 
}

//中序遍历 
void inTree(BiTree T) {
	if(T!=NULL) {
		inTree(T->lchild);
		visit(T);
		inTree(T->rchild);
	}
}

int main(int argc, char** argv) {
	createTree(T);
	cout<<"先序遍历结果："; 
	preTree(T);
	cout<<endl<<"中序遍历结果：";
	inTree(T);
	findAndDeletX(6);
	cout<<endl<<"删除x结点的子树后"<<endl<<"先序遍历结果："; 
	preTree(T);
	cout<<endl<<"中序遍历结果：";
	inTree(T);
	return 0;
}

```

![](/assets/img/2016-08-25-C34/1.png)